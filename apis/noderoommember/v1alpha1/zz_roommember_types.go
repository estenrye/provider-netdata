// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ClauseInitParameters struct {

	// (String) The host label to check.
	// The host label to check.
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// (Boolean) Negate the clause.
	// Negate the clause.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// (String) Operator to compare. Valid values: equals, starts_with, ends_with, contains.
	// Operator to compare. Valid values: equals, starts_with, ends_with, contains.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// (String) The value to compare against.
	// The value to compare against.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ClauseObservation struct {

	// (String) The host label to check.
	// The host label to check.
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// (Boolean) Negate the clause.
	// Negate the clause.
	Negate *bool `json:"negate,omitempty" tf:"negate,omitempty"`

	// (String) Operator to compare. Valid values: equals, starts_with, ends_with, contains.
	// Operator to compare. Valid values: equals, starts_with, ends_with, contains.
	Operator *string `json:"operator,omitempty" tf:"operator,omitempty"`

	// (String) The value to compare against.
	// The value to compare against.
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type ClauseParameters struct {

	// (String) The host label to check.
	// The host label to check.
	// +kubebuilder:validation:Optional
	Label *string `json:"label" tf:"label,omitempty"`

	// (Boolean) Negate the clause.
	// Negate the clause.
	// +kubebuilder:validation:Optional
	Negate *bool `json:"negate" tf:"negate,omitempty"`

	// (String) Operator to compare. Valid values: equals, starts_with, ends_with, contains.
	// Operator to compare. Valid values: equals, starts_with, ends_with, contains.
	// +kubebuilder:validation:Optional
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// (String) The value to compare against.
	// The value to compare against.
	// +kubebuilder:validation:Optional
	Value *string `json:"value" tf:"value,omitempty"`
}

type RoomMemberInitParameters struct {

	// (List of String) List of node names to add to the room. At least one node name is required.
	// List of node names to add to the room. At least one node name is required.
	NodeNames []*string `json:"nodeNames,omitempty" tf:"node_names,omitempty"`

	// (String) The Room ID of the space.
	// The Room ID of the space.
	// +crossplane:generate:reference:type=github.com/estenrye/provider-netdata/apis/room/v1alpha1.Room
	RoomID *string `json:"roomId,omitempty" tf:"room_id,omitempty"`

	// Reference to a Room in room to populate roomId.
	// +kubebuilder:validation:Optional
	RoomIDRef *v1.Reference `json:"roomIdRef,omitempty" tf:"-"`

	// Selector for a Room in room to populate roomId.
	// +kubebuilder:validation:Optional
	RoomIDSelector *v1.Selector `json:"roomIdSelector,omitempty" tf:"-"`

	// (Block List) The node rule to apply to the room. The logical relation between multiple rules is OR. More info here. (see below for nested schema)
	// The node rule to apply to the room. The logical relation between multiple rules is OR. More info [here](https://learn.netdata.cloud/docs/netdata-cloud/spaces-and-rooms/node-rule-based-room-assignment).
	Rule []RuleInitParameters `json:"rule,omitempty" tf:"rule,omitempty"`

	// (String) Space ID of the member.
	// Space ID of the member.
	// +crossplane:generate:reference:type=github.com/estenrye/provider-netdata/apis/space/v1alpha1.Space
	SpaceID *string `json:"spaceId,omitempty" tf:"space_id,omitempty"`

	// Reference to a Space in space to populate spaceId.
	// +kubebuilder:validation:Optional
	SpaceIDRef *v1.Reference `json:"spaceIdRef,omitempty" tf:"-"`

	// Selector for a Space in space to populate spaceId.
	// +kubebuilder:validation:Optional
	SpaceIDSelector *v1.Selector `json:"spaceIdSelector,omitempty" tf:"-"`
}

type RoomMemberObservation struct {

	// (String) The ID of the rule.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (List of String) List of node names to add to the room. At least one node name is required.
	// List of node names to add to the room. At least one node name is required.
	NodeNames []*string `json:"nodeNames,omitempty" tf:"node_names,omitempty"`

	// (String) The Room ID of the space.
	// The Room ID of the space.
	RoomID *string `json:"roomId,omitempty" tf:"room_id,omitempty"`

	// (Block List) The node rule to apply to the room. The logical relation between multiple rules is OR. More info here. (see below for nested schema)
	// The node rule to apply to the room. The logical relation between multiple rules is OR. More info [here](https://learn.netdata.cloud/docs/netdata-cloud/spaces-and-rooms/node-rule-based-room-assignment).
	Rule []RuleObservation `json:"rule,omitempty" tf:"rule,omitempty"`

	// (String) Space ID of the member.
	// Space ID of the member.
	SpaceID *string `json:"spaceId,omitempty" tf:"space_id,omitempty"`
}

type RoomMemberParameters struct {

	// (List of String) List of node names to add to the room. At least one node name is required.
	// List of node names to add to the room. At least one node name is required.
	// +kubebuilder:validation:Optional
	NodeNames []*string `json:"nodeNames,omitempty" tf:"node_names,omitempty"`

	// (String) The Room ID of the space.
	// The Room ID of the space.
	// +crossplane:generate:reference:type=github.com/estenrye/provider-netdata/apis/room/v1alpha1.Room
	// +kubebuilder:validation:Optional
	RoomID *string `json:"roomId,omitempty" tf:"room_id,omitempty"`

	// Reference to a Room in room to populate roomId.
	// +kubebuilder:validation:Optional
	RoomIDRef *v1.Reference `json:"roomIdRef,omitempty" tf:"-"`

	// Selector for a Room in room to populate roomId.
	// +kubebuilder:validation:Optional
	RoomIDSelector *v1.Selector `json:"roomIdSelector,omitempty" tf:"-"`

	// (Block List) The node rule to apply to the room. The logical relation between multiple rules is OR. More info here. (see below for nested schema)
	// The node rule to apply to the room. The logical relation between multiple rules is OR. More info [here](https://learn.netdata.cloud/docs/netdata-cloud/spaces-and-rooms/node-rule-based-room-assignment).
	// +kubebuilder:validation:Optional
	Rule []RuleParameters `json:"rule,omitempty" tf:"rule,omitempty"`

	// (String) Space ID of the member.
	// Space ID of the member.
	// +crossplane:generate:reference:type=github.com/estenrye/provider-netdata/apis/space/v1alpha1.Space
	// +kubebuilder:validation:Optional
	SpaceID *string `json:"spaceId,omitempty" tf:"space_id,omitempty"`

	// Reference to a Space in space to populate spaceId.
	// +kubebuilder:validation:Optional
	SpaceIDRef *v1.Reference `json:"spaceIdRef,omitempty" tf:"-"`

	// Selector for a Space in space to populate spaceId.
	// +kubebuilder:validation:Optional
	SpaceIDSelector *v1.Selector `json:"spaceIdSelector,omitempty" tf:"-"`
}

type RuleInitParameters struct {

	// (String) Determines whether matching nodes will be included or excluded from the room. Valid values: INCLUDE or EXCLUDE. EXCLUDE action always takes precedence against INCLUDE.
	// Determines whether matching nodes will be included or excluded from the room. Valid values: INCLUDE or EXCLUDE. EXCLUDE action always takes precedence against INCLUDE.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// (Block List) The clause to apply to the rule. The logical relation between multiple clauses is AND. It should be a least one clause. (see below for nested schema)
	// The clause to apply to the rule. The logical relation between multiple clauses is AND. It should be a least one clause.
	Clause []ClauseInitParameters `json:"clause,omitempty" tf:"clause,omitempty"`

	// (String) The description of the rule.
	// The description of the rule.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`
}

type RuleObservation struct {

	// (String) Determines whether matching nodes will be included or excluded from the room. Valid values: INCLUDE or EXCLUDE. EXCLUDE action always takes precedence against INCLUDE.
	// Determines whether matching nodes will be included or excluded from the room. Valid values: INCLUDE or EXCLUDE. EXCLUDE action always takes precedence against INCLUDE.
	Action *string `json:"action,omitempty" tf:"action,omitempty"`

	// (Block List) The clause to apply to the rule. The logical relation between multiple clauses is AND. It should be a least one clause. (see below for nested schema)
	// The clause to apply to the rule. The logical relation between multiple clauses is AND. It should be a least one clause.
	Clause []ClauseObservation `json:"clause,omitempty" tf:"clause,omitempty"`

	// (String) The description of the rule.
	// The description of the rule.
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// (String) The ID of the rule.
	// The ID of the rule.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type RuleParameters struct {

	// (String) Determines whether matching nodes will be included or excluded from the room. Valid values: INCLUDE or EXCLUDE. EXCLUDE action always takes precedence against INCLUDE.
	// Determines whether matching nodes will be included or excluded from the room. Valid values: INCLUDE or EXCLUDE. EXCLUDE action always takes precedence against INCLUDE.
	// +kubebuilder:validation:Optional
	Action *string `json:"action" tf:"action,omitempty"`

	// (Block List) The clause to apply to the rule. The logical relation between multiple clauses is AND. It should be a least one clause. (see below for nested schema)
	// The clause to apply to the rule. The logical relation between multiple clauses is AND. It should be a least one clause.
	// +kubebuilder:validation:Optional
	Clause []ClauseParameters `json:"clause,omitempty" tf:"clause,omitempty"`

	// (String) The description of the rule.
	// The description of the rule.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`
}

// RoomMemberSpec defines the desired state of RoomMember
type RoomMemberSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RoomMemberParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider RoomMemberInitParameters `json:"initProvider,omitempty"`
}

// RoomMemberStatus defines the observed state of RoomMember.
type RoomMemberStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RoomMemberObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// RoomMember is the Schema for the RoomMembers API. Provides a Netdata Cloud Node Room Member resource. Use this resource to manage node membership to the room in the selected space. There are two options to add nodes to the room: providing the node names directly, but only reachable nodes will be added to the room, use node_names attribute for thiscreating rules that will automatically add nodes to the room based on the rule, use rule block for this
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,netdata}
type RoomMember struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RoomMemberSpec   `json:"spec"`
	Status            RoomMemberStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RoomMemberList contains a list of RoomMembers
type RoomMemberList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []RoomMember `json:"items"`
}

// Repository type metadata.
var (
	RoomMember_Kind             = "RoomMember"
	RoomMember_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: RoomMember_Kind}.String()
	RoomMember_KindAPIVersion   = RoomMember_Kind + "." + CRDGroupVersion.String()
	RoomMember_GroupVersionKind = CRDGroupVersion.WithKind(RoomMember_Kind)
)

func init() {
	SchemeBuilder.Register(&RoomMember{}, &RoomMemberList{})
}
